<!doctype html>
<meta charset="utf-8" />
<title>Text Field Number Extractor (N‑th token, exact decimals)</title>
<style>
  /* Light theme, high contrast */
  html, body { background:#fff; color:#000; }
  body { font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; margin:2rem; line-height:1.45; }
  h1 { margin:.2rem 0 1rem; }
  .row { display:flex; gap:.75rem; align-items:center; flex-wrap:wrap; margin-bottom:.75rem; }
  textarea { width:100%; min-height:42vh; padding:.75rem; border-radius:8px; border:1px solid #9994;
             font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#fff; color:#000; }
  button { padding:.5rem .9rem; border-radius:6px; border:1px solid #8885; background:#f3f3f3; color:#000; cursor:pointer; }
  button:disabled { opacity:.5; cursor:not-allowed; }
  .muted { color:#333; }
  .ok { color:#0a7a0a; }
  .err { color:#c00; font-weight:600; }
  pre { background:#fafafa; color:#000; padding:1rem; border-radius:6px; overflow:auto; border:1px solid #eee; }
  code.badge { background:#eee; padding:.1rem .35rem; border-radius:4px; }
  input, select { background:#fff; color:#000; border:1px solid #ccc; padding:.35rem .5rem; border-radius:6px; }
  input[type="number"] { width:5.5rem; }
</style>

<h1>Text Field Number Extractor</h1>

<p class="muted">
  Paste text below, specify a <b>key</b>, and this tool will locate each line containing that key and extract the
  <b>N‑th number</b> that appears after it.  
  Supports <b>integers and decimals</b>, handles thousands separators, and performs <b>exact decimal summation</b>
  using BigInt scaling (no floating‑point errors).  
  Choose your <b>decimal separator</b> and pattern matching mode.
</p>

<div class="row">
  <label>Key:
    <input id="key" value="KRT" />
  </label>

  <label>Pattern:
    <select id="mode">
      <option value="strict">strict (requires <code>:</code> or <code>=</code> after key)</option>
      <option value="loose" selected>loose (numbers anywhere to the right on the same line)</option>
    </select>
  </label>

  <label>N‑th number:
    <input id="nth" type="number" min="1" step="1" value="1" />
  </label>

  <label>Decimal separator:
    <select id="decSep">
      <option value="," selected>Comma “,”</option>
      <option value=".">Dot “.”</option>
    </select>
  </label>

  <label>
    <input type="checkbox" id="multiline" checked>
    multi-line text
  </label>

  <button id="scanBtn">Scan</button>
  <button id="copyBtn" disabled>Copy results</button>
</div>

<textarea id="txt" placeholder="Paste your plain text here...">DEMO — Example scan text
=====================================
This example shows common cases. Try different settings above and press "Scan".

• Use case A — Loose mode, N=1, decimal separator = comma (,)
  KRT 8,00 1615 43,67 4000 0,88 850 17,00 860 5,00
  -> Captures the first number after the key: 8,00

• Use case B — Loose mode, N=2 (second number), decimal separator = comma
  KRT 8,00 1615 43,67
  -> With N=2 captures 1615

• Use case C — Strict mode with ":" (Mode=strict), N=1, decimal separator = comma
  KRT: 12,50 widgets
  -> Requires ':' or '=' after the key; captures 12,50

• Use case D — Strict mode with "=", thousands spacing, decimal separator = comma
  KRT = 1 234,75
  -> Space is treated as thousands separator; captures 1 234,75

• Use case E — Dot decimals (set decimal separator = dot ".")
  KRT 3.25 apples
  -> Captures 3.25

• Use case F — Integers and negatives (no decimal part)
  KRT 2000
  KRT: -150
  -> Captures 2000 and -150 correctly

• Use case G — N‑th number selection (Mode=strict)
  KRT: 10 20 30
  -> With N=3 captures 30

• Use case H — Other thousands separators ignored (with comma decimal)
  KRT 1.234,00
  KRT 1'234,5
  KRT 1_234,75
  -> Dot/apostrophe/underscore are treated as thousands separators

• Use case I — Only lines that contain the key are counted
  NO_KEY 999
  -> Ignored

Now press the "Scan" button above to see the matches and the total.
</textarea>

<p id="status" class="muted">Ready.</p>
<div id="out"></div>

<script>
/* ===== Key location (case-insensitive, boundary-ish) ===== */
function keyRegex(key) {
  const esc = key.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  return new RegExp(`(^|[^A-Za-z0-9_])(${esc})(?![A-Za-z0-9_])`, "i");
}

/* ===== Build a number-token pattern based on chosen decimal separator ===== */
function buildTokenPieces(decSep) {
  const ds = decSep === "," ? "," : "\\.";
  const other = decSep === "," ? "\\." : ",";
  const thousands = `[\\s_'’${other}]`;
  const intPart = `(?:\\d{1,3}(?:${thousands}?\\d{3})+|\\d+)`;
  const fracPart = `(?:${ds}\\d+)?`;
  const token = `[+\\-]?${intPart}${fracPart}`;
  return { token, ds, other };
}

/* ===== Extract the N-th token after the key =====
   - Loose: count tokens anywhere to the right
   - Strict: require the first ':' or '=' after key; count tokens after it
*/
function extractNthTokenRightOf(lineRight, decSep, nth, strict) {
  const { token } = buildTokenPieces(decSep);
  const tokenRe = new RegExp(token, "g");

  let search = lineRight;
  if (strict) {
    const sign = /[:=]/.exec(lineRight);
    if (!sign) return null;
    search = lineRight.slice(sign.index + 1);
  }

  let i = 0, m;
  while ((m = tokenRe.exec(search)) !== null) {
    i++;
    if (i === nth) return m[0];
    if (m.index === tokenRe.lastIndex) tokenRe.lastIndex++;
  }
  return null;
}

/* ===== Unified number parser (integer OR decimal) ===== */
function parseDecimalOrInteger(token, decSep) {
  token = String(token).trim();
  let sign = 1n;
  if (token.startsWith("+")) token = token.slice(1);
  else if (token.startsWith("-")) { sign = -1n; token = token.slice(1); }

  const other = decSep === "," ? "\\." : ",";
  token = token.replace(new RegExp(`[\\s_'’${other}]`, "g"), "");
  const isDecimal = token.includes(decSep);

  if (!isDecimal) {
    if (!/^\d+$/.test(token)) throw new Error("invalid integer");
    return { scaled: BigInt(token) * sign, scale: 0 };
  }

  const idx = token.lastIndexOf(decSep);
  let intPart = token.slice(0, idx);
  let fracPart = token.slice(idx + 1);

  if (!/^\d*$/.test(intPart) || !/^\d+$/.test(fracPart))
    throw new Error("invalid decimal");

  if (intPart === "") intPart = "0";
  const MAX_DEC = 12;
  fracPart = fracPart.slice(0, MAX_DEC);

  const scale = fracPart.length;
  const intBI = BigInt(intPart);
  const fracBI = BigInt(fracPart);
  const scaled = (intBI * (10n ** BigInt(scale)) + fracBI) * sign;

  return { scaled, scale };
}

/* ===== Exact summation for mixed integers + decimals ===== */
function sumMixedNumbers(values) {
  if (!values.length) return { scaled: 0n, scale: 0 };
  const maxScale = values.reduce((m, v) => Math.max(m, v.scale), 0);
  let total = 0n;
  for (const v of values)
    total += v.scaled * (10n ** BigInt(maxScale - v.scale));
  return { scaled: total, scale: maxScale };
}

/* ===== Format scaled number back to string ===== */
function formatScaled({ scaled, scale }, decSep) {
  const sign = scaled < 0n ? "-" : "";
  let s = (scaled < 0n ? -scaled : scaled).toString();
  if (scale === 0) return sign + s;
  if (s.length <= scale)
    s = "0".repeat(scale - s.length + 1) + s;
  const intStr = s.slice(0, s.length - scale);
  const fracStr = s.slice(s.length - scale);
  return sign + intStr + decSep + fracStr;
}

/* ===== Main scan routine ===== */
function scanText(text, key, patternMode, nth, decSep, multiline = true) {
  const lines = multiline ? text.split(/\r?\n/) : [text];
  const matches = [], parts = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const km = keyRegex(key).exec(line);
    if (!km) continue;

    const right = line.slice(km.index + km[0].length);
    const token = extractNthTokenRightOf(right, decSep, nth, patternMode === "strict");
    if (!token) continue;

    try {
      const val = parseDecimalOrInteger(token, decSep);
      matches.push({ lineNo: i + 1, line, raw: token, valueScaled: val });
      parts.push(val);
    } catch {}
  }

  return { matches, total: sumMixedNumbers(parts) };
}

/* ===== UI ===== */
const txt = document.getElementById("txt");
const keyEl = document.getElementById("key");
const modeEl = document.getElementById("mode");
const nthEl = document.getElementById("nth");
const decSepEl = document.getElementById("decSep");
const multiEl = document.getElementById("multiline");
const scanBtn = document.getElementById("scanBtn");
const copyBtn = document.getElementById("copyBtn");
const statusEl = document.getElementById("status");
const outEl = document.getElementById("out");

function renderResult(res, key, decSep, nth) {
  const lines = [];
  if (!res.matches.length) {
    lines.push(`[--] no matches for key '${key}'`);
  } else {
    for (const m of res.matches) {
      const s = formatScaled(m.valueScaled, decSep);
      lines.push(`[OK] line ${m.lineNo}  value (N=${nth}): ${s}  (token: "${m.raw}")`);
      lines.push(`     ${m.line}`);
    }
    const totalStr = formatScaled(res.total, decSep);
    lines.push(`\n=== TOTAL for key '${key}' (N=${nth}): ${totalStr} ===`);
  }
  outEl.innerHTML = "<pre>"+lines.join("\n")+"</pre>";
  copyBtn.disabled = false;
  return lines.join("\n");
}

let lastRendered = "";
scanBtn.addEventListener("click", () => {
  const key = (keyEl.value || "key").trim();
  const mode = modeEl.value;
  const nth = Math.max(1, parseInt(nthEl.value || "1", 10));
  const decSep = decSepEl.value;
  const multiline = multiEl.checked;

  statusEl.textContent = `Scanning (${mode}, N=${nth}, dec='${decSep}')…`;
  try {
    const res = scanText(txt.value, key, mode, nth, decSep, multiline);
    lastRendered = renderResult(res, key, decSep, nth);
    statusEl.innerHTML = `<span class="ok">Done.</span>`;
  } catch (e) {
    statusEl.innerHTML = `<span class="err">Error: ${e.message}</span>`;
  }
});

copyBtn.addEventListener("click", () => {
  if (!lastRendered) return;
  navigator.clipboard.writeText(lastRendered)
    .then(() => statusEl.innerHTML = `<span class="ok">Copied.</span>`)
    .catch(() => statusEl.innerHTML = `<span class="err">Copy failed.</span>`);
});
</script>
