<!doctype html>
<meta charset="utf-8" />
<title>Sum Value Fields from Pasted Text (Light Theme, First Number Only)</title>
<style>
  /* Force light theme, high contrast */
  html, body { background: #ffffff; color: #000000; }
  body { font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; margin: 2rem; line-height: 1.45; }
  h1 { margin: .2rem 0 1rem; }
  .row { display:flex; gap:.75rem; align-items:center; flex-wrap:wrap; margin-bottom:.75rem; }
  textarea { width: 100%; min-height: 40vh; padding: .75rem; border-radius: 8px; border: 1px solid #9994;
             font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#fff; color:#000; }
  button { padding: .5rem .9rem; border-radius: 6px; border: 1px solid #8885; background: #f3f3f3; color:#000; cursor: pointer; }
  button:disabled { opacity:.5; cursor:not-allowed; }
  .muted { color:#333; }
  .ok { color:#0a7a0a; }
  .err { color:#c00; font-weight:600; }
  pre { background:#fafafa; color:#000; padding:1rem; border-radius:6px; overflow:auto; border:1px solid #eee; }
  code.badge { background:#eee; padding:.1rem .35rem; border-radius:4px; }
  input, select { background:#fff; color:#000; border:1px solid #ccc; padding:.35rem .5rem; border-radius:6px; }
</style>

<h1>Sum <code class="badge">Value Fields</code> from Pasted Text</h1>
<p class="muted">
  Paste your text below. The tool finds <b>Value Fields (case‑insensitive) and sums <b>the first integer number token</b> that appears
  after the key on the same line. (Examples: <code>_KrT 8,00 ... → 8</code>, <code>_KrT: 1.234 → 1234</code>).
</p>

<div class="row">
  <label>Key:
    <input id="key" value="_KrT" style="width:10rem;">
  </label>

  <label>Pattern:
    <select id="mode">
      <option value="strict">strict (key followed by := and number)</option>
      <option value="loose" selected>loose (take the first number after key on the same line)</option>
    </select>
  </label>

  <label>
    <input type="checkbox" id="multiline" checked>
    multi-line text (default)
  </label>

  <button id="scanBtn">Scan</button>
  <button id="copyBtn" disabled>Copy results</button>
</div>

<textarea id="txt" placeholder="Paste your plain text here..."></textarea>

<p id="status" class="muted">Ready.</p>
<div id="out"></div>

<script>
/* ===== Integer parsing (keeps sign, ignores decimals) =====
   Accepts:
     1,234   -> 1234
     1.234   -> 1234
     1 234   -> 1234
     -1_234  -> -1234
     8,00    -> 8   (decimal part dropped by design)
*/
function coerceIntegerToken(s) {
  if (!s) throw new Error("empty token");
  s = String(s).trim();

  // Optional leading sign
  let sign = 1;
  if (s.startsWith("+")) { s = s.slice(1); }
  else if (s.startsWith("-")) { sign = -1; s = s.slice(1); }

  // If a decimal separator exists, strip the fractional part (you said values are whole)
  const decIdx = Math.max(s.lastIndexOf(","), s.lastIndexOf("."));
  if (decIdx >= 0) s = s.slice(0, decIdx);

  // Remove thousand separators and spacing-like chars
  s = s.replace(/[,\.\s_'’]/g, "");

  if (!/^\d+$/.test(s)) throw new Error("not an integer token");
  return sign * parseInt(s, 10);
}

/* ===== Tokenizer: FIRST number after the key (not greedy) =====
   We do not let regex gobble multiple numbers.
   We find the key, slice the line to the right, and then match the FIRST numeric token only.
*/
function firstNumberTokenAfter(textRight) {
  // A number token: optional sign + digits with optional thousand separators, optional decimals.
  // We capture only the token; no spaces allowed inside beyond separators.
  const re = /^[^\S\r\n]*[:=]?[^\S\r\n]*([+\-]?\d[\d _'’]*?(?:[.,]\d+)?)/i;
  const m = re.exec(textRight);
  return m ? m[1] : null;
}

/* Build a case-insensitive regex for the key, with word boundary-ish behavior. */
function keyRegex(key) {
  const esc = key.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  // Use \b where it works, plus allow _ to be part of the word.
  return new RegExp(`(^|[^A-Za-z0-9_])(${esc})(?![A-Za-z0-9_])`, "i");
}

/* Main scan per line */
function scanLine(line, key, mode) {
  const kRe = keyRegex(key);
  const m = kRe.exec(line);
  if (!m) return null;

  const idxAfterKey = m.index + m[0].length; // end of the delimiter+key match
  const right = line.slice(idxAfterKey);

  let token = null;
  if (mode === "strict") {
    // Require := before the number token
    const m2 = right.match(/^[^\S\r\n]*[:=][^\S\r\n]*([+\-]?\d[\d _'’]*?(?:[.,]\d+)?)/);
    token = m2 ? m2[1] : null;
  } else {
    // Loose: take the first number token that appears after the key
    token = firstNumberTokenAfter(right);
  }

  if (!token) return null;

  try {
    const value = coerceIntegerToken(token);
    return { value, raw: token };
  } catch {
    return null;
  }
}

function scanText(text, key, mode, multiline=true) {
  if (!text) return { matches: [], sum: 0 };
  const lines = multiline ? text.split(/\r?\n/) : [text];
  const matches = [];
  let sum = 0;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const hit = scanLine(line, key, mode);
    if (hit) {
      matches.push({ lineNo: i+1, line, value: hit.value, raw: hit.raw });
      sum += hit.value; // pure integer addition
    }
  }
  return { matches, sum };
}

/* ---------- UI wiring ---------- */
const txt = document.getElementById("txt");
const keyEl = document.getElementById("key");
const modeEl = document.getElementById("mode");
const multiEl = document.getElementById("multiline");
const scanBtn = document.getElementById("scanBtn");
const copyBtn = document.getElementById("copyBtn");
const statusEl = document.getElementById("status");
const outEl = document.getElementById("out");

function fmt(n) { return Number.isFinite(n) ? n.toString() : String(n); }

function renderResult(res, key) {
  const lines = [];
  if (!res.matches.length) {
    lines.push(`[--] no occurrences of '${key}' found`);
  } else {
    for (const m of res.matches) {
      lines.push(`[OK] line ${m.lineNo}  value: ${fmt(m.value)}  (raw: "${m.raw}")`);
      lines.push(`     ${m.line}`);
    }
    lines.push(`\n=== GRAND TOTAL for '${key}': ${fmt(res.sum)} ===`);
  }
  outEl.innerHTML = "<pre>"+lines.join("\n")+"</pre>";
  copyBtn.disabled = false;
  return lines.join("\n");
}

let lastRendered = "";
scanBtn.addEventListener("click", () => {
  const key = (keyEl.value || "_KrT").trim();
  const mode = modeEl.value;
  const multiline = multiEl.checked;
  statusEl.textContent = `Scanning (${mode}, ${multiline ? "multi-line" : "single-line"})…`;
  try {
    const res = scanText(txt.value, key, mode, multiline);
    lastRendered = renderResult(res, key);
    statusEl.innerHTML = `<span class="ok">Done.</span>`;
  } catch (e) {
    statusEl.innerHTML = `<span class="err">Error: ${e?.message || e}</span>`;
  }
});

copyBtn.addEventListener("click", () => {
  if (!lastRendered) return;
  navigator.clipboard.writeText(lastRendered).then(() => {
    statusEl.innerHTML = `<span class="ok">Results copied to clipboard.</span>`;
  }).catch(() => {
    statusEl.innerHTML = `<span class="err">Could not copy to clipboard.</span>`;
  });
});
</script>
``
